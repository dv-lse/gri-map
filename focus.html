<!DOCTYPE html>
<meta charset='UTF-8'>
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<title>GRI Map Focus Tool</title>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-geo.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v1.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>
<script src="https://d3js.org/d3-queue.v3.min.js"></script>


<div id="wrapper">
  <div id="content">
    <div id="readout"></div>
    <div id="gri-map"></div>
    <textarea id="output" style="width:500px;height:500px"></textarea>
  </div>
</div>

<script>

    const WORLD_MAP = 'world/50m.json'
    const FOCI = 'data/foci.csv'

    let width = 960
    let height = 600

    let svg = d3.select('#gri-map')
      .append('svg')
        .style('border', '1px dotted red')
        .attr('width', width)
        .attr('height', height)

    d3.queue()
      .defer(d3.json, WORLD_MAP)
      .defer(d3.csv, FOCI)
      .await( (err, world, foci) => {
        if(err) throw err

        let cur = 0

        foci.forEach((d) => (d.x = +d.x, d.y = +d.y, d.scale = +d.scale))

        foci = foci.reduce( (m,d) => (m[d.iso] = d, m), {})

        let features = topojson.feature(world, world.objects.countries).features

        let projection = d3.geoEckert3()
          .scale(180)
          .translate([0, 0])
          .precision(.1)

        let path = d3.geoPath()
          .projection(projection)

        let g = svg.append('g')

        g.selectAll('path')
            .data(features)
          .enter().append('path')
            .attr('d', path)
            .attr('stroke', 'black')
            .attr('fill', 'white')


        let zoom = d3.zoom()
          .scaleExtent([0.9, 8])
          .translateExtent([[-width/2,-height/2],[width/2,height/2]])
          .on('zoom', () => {
            let t = d3.event.transform
            g.attr('transform', t)
             .style('stroke-width', 1.5 / t.k + 'px')
          })

        svg.call(zoom)
           .call(zoom.transform, d3.zoomIdentity
                                   .translate(width/2, height/2))
        features.forEach((d) => {
          if(!(d.id in foci)) {
            foci[d.id] = focus_coords(d.id)
          }
        })

        output()

        document.addEventListener("keydown", function(event) {
          switch(event.which) {
            case 37: cur = Math.max(0, cur-1); break;
            case 39: cur = Math.min(cur+1, features.length); break;
          }
          event.stopPropagation()
          let f = features[cur]
          let t = foci[f.iso]

          output()
        })

        function csv2geojson(t) {
          return { id: t.iso, type: "MultiPoint", coordinates: [[t.x0, t.y0], [t.x1, t.y1]] }
        }

        function output() {
          let f = features[cur]
          d3.select('#readout').html(JSON.stringify(csv2geojson(foci[f.id])))

          g.transition('zoom')
            .duration(2000)
            .call(zoom.transform, zoomTransform(focus_id))

          let csv = d3.csvFormat(d3.values(foci))
          d3.select('#output').node().value = csv
        }

        function focus_coords(id) {
          let sel_features = features.filter( (d) => d.id === id )
          let areas = sel_features.map(d3.geoArea)
          let idx = d3.range(0,areas.length).sort((a,b) => d3.descending(areas[a], areas[b]))[0]

          let bounds = d3.geoBounds(sel_features[idx])
          return { iso: id, x0: bounds[0][0], y0: bounds[0][1], x1: bounds[1][0], y1: bounds[1][1]}
        }

        function zoom_to(id) {
          // c.f. https://bl.ocks.org/iamkevinv/0a24e9126cd2fa6b283c6f2d774b69a2

          let r = foci[id]
          let bounds = [projection([r.x0, r.y0]), projection([r.x1, r.y1])]

          let dx = bounds[1][0] - bounds[0][0]
          let dy = bounds[1][1] - bounds[0][1]
          let x = (bounds[0][0] + bounds[1][0]) / 2
          let y = (bounds[0][1] + bounds[1][1]) / 2
          let scale = Math.max(dx / width, dy / height)
          let translate = [width / 2 - scale * x, height / 2 - scale * y]

          return { translate: translate, scale: scale }
        }
      })
</script>
